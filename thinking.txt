let x = [1, 2, 3][0]
-- Typeclass Expr: [Type]
-- Int: Type (~ [[String -> [(Int, String)])
-- Rule (Typeclass ListExtractable: [Type t -> String -> [(t, Type, String)]])
-- Rule listExtraction: Type t -> String -> [(t, Type, String)]

let x = [1, 2, 3]
-- Typeclass Expr
-- List: Type -> Type

One method: have just a regular List type, but have the values be tuples ([Type], Type). Then x = [1, 2, 3] is trivial (assuming you can get the parsed type back out of a typeclass parsing, which should be fine), and if you ever want to parse a List Int, you have a special function for parsing lists that checks whether the returned thing matches the specified type.

What would it look like to explicitly have a type system?
